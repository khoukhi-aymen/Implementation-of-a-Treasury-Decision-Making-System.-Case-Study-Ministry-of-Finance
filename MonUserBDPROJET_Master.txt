create tablespace projet_master  datafile 'C:\tbs\projet_master.dat' size 100M autoextend on online;
create temporary tablespace projet_masterTBS  tempfile 'C:\tbs\projet_masterTBS  .dat' size 100M autoextend on;
ALTER SESSION SET"_ORACLE_SCRIPT" = TRUE;
create user projetMaster identified by psw default tablespace projet_master temporary tablespace projet_masterTBS;
grant all privileges to projetMaster;
connect projetMaster/psw;

connecter via sqlplus : ouvrir le dossier app et puis ouvrir le cmd dans ce dossier et puis taper :
sqlplus sys/Omar@ORCL as sysdba


CREATE TABLE utilisateur (
    id NUMBER,
    Nom VARCHAR2(100),
	Email VARCHAR2(100),
	Mot_De_Passe VARCHAR2(255),
	Role VARCHAR2(50),
    CONSTRAINT pk_id PRIMARY KEY (id)
);

CREATE SEQUENCE utilisateur_seq
    START WITH 1
    INCREMENT BY 1
    NOCACHE;
	
CREATE TABLE sessions (
    session_id VARCHAR2(255) PRIMARY KEY,
    session_data CLOB
);

					   
--- création de la table AxeProgramatique------------
					   
Create table AxeProgramatique (
                       code_Portef VARCHAR2(255),
                       LIB_PORTEF VARCHAR2(255),
					   PROGRAMME VARCHAR2(255),
					   SOUS_PROGRAMME VARCHAR2(255),
					   LIBELLE VARCHAR2(255),
					   CONSTRAINT pk_AxeProgramatique PRIMARY KEY (code_Portef,PROGRAMME,SOUS_PROGRAMME)
					   );
					   

--- création de la table AxeEconomique------------					   
					   
Create table AxeEconomique (
                       AXE_ECO VARCHAR2(255),
                       LIBELLE VARCHAR2(255),
					   CONSTRAINT pk_AxeEconomique PRIMARY KEY (AXE_ECO)
					   );
					   
					   
--- création de la table Action------------					   
Create table Action (
                       CODE_PORTEF VARCHAR2(255),
                       PROGRAMME VARCHAR2(255),
					   SOUS_PROGRAMME VARCHAR2(255),
					   ACTION VARCHAR2(255),
					   SOUS_ACTION VARCHAR2(255),
					   LIBELLE_ACTION VARCHAR2(255),
					   CONSTRAINT pk_Action PRIMARY KEY (CODE_PORTEF,PROGRAMME,SOUS_PROGRAMME,ACTION,SOUS_ACTION),
					   CONSTRAINT fk_Action_AxeProgramatique FOREIGN KEY (CODE_PORTEF,PROGRAMME,SOUS_PROGRAMME) REFERENCES AxeProgramatique (code_Portef,PROGRAMME,SOUS_PROGRAMME)
					   );
					   
					   
					   
--- création de la table Ordonnateur------------					   
					   
Create table Ordonnateur (
                       CODE_ORD VARCHAR2(255),
                       LIBELLE_ORD VARCHAR2(255),
					   CODE_WILAYA VARCHAR2(255),
					   CONSTRAINT pk_Ordonnateur PRIMARY KEY (CODE_ORD),
					   CONSTRAINT fk_Ordonnateur_wilayas FOREIGN KEY (CODE_WILAYA) REFERENCES Wilayas (CODE_WILAYA)
					   );


--- création de la table Wilayas------------					   
					   
Create table Wilayas (
                       CODE_WILAYA VARCHAR2(255),
                       LIBELLE_WILAYA VARCHAR2(255),
					   CONSTRAINT pk_Wilaya PRIMARY KEY (CODE_WILAYA)
					   );		


--- création de la table Soumissionaire------------					   
					   
Create table Soumissionaire (
                       CODE_Soumissionaire VARCHAR2(255),
                       Type_Soumissionaire VARCHAR2(255),
					   libelle_Soumissionaire VARCHAR2(255),
					   CONSTRAINT pk_Soumissionaire PRIMARY KEY (CODE_Soumissionaire)
					   );						   

--- création de la table CREDIT------------

Create table CREDIT (
                       GESTION VARCHAR2(255),
                       MOIS VARCHAR2(255),
					   CODE_ORD VARCHAR2(255),
					   CODE_PORTEF VARCHAR2(255),
					   PROGRAMME VARCHAR2(255),
					   SOUS_PROGRAMME VARCHAR2(255),
					   ACTION VARCHAR2(255),
					   SOUS_ACTION VARCHAR2(255),
					   AXE_ECO VARCHAR2(255),
					   DISPOS VARCHAR2(255),
					   TOT_CREDIT VARCHAR2(255),
					   TOT_DEB VARCHAR2(255),
					   SOLDE VARCHAR2(255),
					   CONSTRAINT fk_CREDIT_AxeProgramatique FOREIGN KEY (CODE_PORTEF,PROGRAMME,SOUS_PROGRAMME) REFERENCES AxeProgramatique (code_Portef,PROGRAMME,SOUS_PROGRAMME),
					   CONSTRAINT fk_CREDIT_Action FOREIGN KEY (CODE_PORTEF,PROGRAMME,SOUS_PROGRAMME,ACTION,SOUS_ACTION) REFERENCES Action (CODE_PORTEF,PROGRAMME,SOUS_PROGRAMME,ACTION,SOUS_ACTION),
					   CONSTRAINT fk_CREDIT_Ordonnateur FOREIGN KEY (CODE_ORD) REFERENCES Ordonnateur (CODE_ORD),
					   CONSTRAINT fk_CREDIT_AxeEconomique FOREIGN KEY (AXE_ECO) REFERENCES AxeEconomique (AXE_ECO),
					   CONSTRAINT pk_CREDIT PRIMARY KEY (GESTION,MOIS,CODE_ORD,CODE_PORTEF,PROGRAMME,SOUS_PROGRAMME,ACTION,SOUS_ACTION,AXE_ECO,DISPOS,TOT_CREDIT,TOT_DEB,SOLDE)
					   
					   );
					   
					   
--- création de la table Mandat------------

Create table Mandat (
                       CODE_PORTEF VARCHAR2(255),
					   CODE_ORD VARCHAR2(255),
					   GESTION VARCHAR2(255),
					   CODE_MANDAT VARCHAR2(255),
					   DT_EMISSION VARCHAR2(255),
					   STATUT VARCHAR2(255),
					   PROGRAMME VARCHAR2(255),
					   SOUS_PROGRAMME VARCHAR2(255),
					   ACTION VARCHAR2(255),
					   SOUS_ACTION VARCHAR2(255),
					   AXE_ECO VARCHAR2(255),
					   DISPOS VARCHAR2(255),
					   MONTANT VARCHAR2(255),
					   CONSTRAINT fk_Mandat_AxeProgramatique FOREIGN KEY (CODE_PORTEF,PROGRAMME,SOUS_PROGRAMME) REFERENCES AxeProgramatique (code_Portef,PROGRAMME,SOUS_PROGRAMME),
					   CONSTRAINT fk_Mandat_Action FOREIGN KEY (CODE_PORTEF,PROGRAMME,SOUS_PROGRAMME,ACTION,SOUS_ACTION) REFERENCES Action (CODE_PORTEF,PROGRAMME,SOUS_PROGRAMME,ACTION,SOUS_ACTION),
					   CONSTRAINT fk_Mandat_Ordonnateur FOREIGN KEY (CODE_ORD) REFERENCES Ordonnateur (CODE_ORD),
					   CONSTRAINT pk_MANDAT PRIMARY KEY (CODE_PORTEF,CODE_ORD ,GESTION ,CODE_MANDAT ,DT_EMISSION ,STATUT ,PROGRAMME ,SOUS_PROGRAMME ,ACTION ,SOUS_ACTION ,AXE_ECO,DISPOS,MONTANT)
					   );
	
	
--- création de la table Recette------------


Create table Recette (
                       GESTION VARCHAR2(255),
					   MOIS VARCHAR2(255),
					   CODE_CPT VARCHAR2(255),
					   LIB_CPT_G VARCHAR2(255),
					   POSTE_C VARCHAR2(255),
					   MT_MOIS VARCHAR2(255),
					   CONSTRAINT fk_Recette_Wilayas FOREIGN KEY (POSTE_C) REFERENCES Wilayas (CODE_WILAYA)
					   );	


--- création de la table Dette------------


Create table Dette (
                       code_ISIN VARCHAR2(255),
					   DATE_DEB VARCHAR2(255),
					   DUREE_bon VARCHAR2(255),
					   DATE_ECHEANCE VARCHAR2(255),
					   Code_Soumissionaire VARCHAR2(255),
					   MONTANT_Propose_Par_etat VARCHAR2(255),
					   Montant_Propose_Par_Soumissionaire VARCHAR2(255),
					   Montant_Adjuge VARCHAR2(255),
					   Montant_Coupoun VARCHAR2(255),
					   CONSTRAINT fk_Dette_Soumissionaire FOREIGN KEY (Code_Soumissionaire) REFERENCES Soumissionaire (CODE_Soumissionaire),
					   CONSTRAINT pk_Dette PRIMARY KEY (code_ISIN,DATE_DEB ,DUREE_bon ,DATE_ECHEANCE ,Code_Soumissionaire ,MONTANT_Propose_Par_etat ,Montant_Propose_Par_Soumissionaire ,Montant_Adjuge ,Montant_Coupoun)
					   );					   


					   

					   
					   
					   
                                    /* partie iI : Création d’un magasin de données*/
--- création d'un nouvel l'utilisateur------------
create user Master2IL identified by psw;
---- accorder les touts les droits----------
grant all privileges to Master2IL ;
--- connexion avec l'utilisateur Master  
connect Master2IL/psw;


/****************************************************FAIT CREDIT************************************************/

--- création de la table Ordonnateur------------


Create table DimensionOrdonnateur (Id_Ordonnateur NUMBER PRIMARY KEY,
                       Code_Ordonnateur  VARCHAR2(255),
					   Libelle_Ordonnateur VARCHAR2(255)
					   );
					   

CREATE SEQUENCE seqOrdonnateur MINVALUE 1 MAXVALUE 100000 START WITH 1 INCREMENT BY 1;




--- création de la table Wilayas------------


Create table DimensionWilayas (Id_Wilayas NUMBER PRIMARY KEY,
                       CODE_WILAYA  VARCHAR2(255),
					   LIBELLE_WILAYA VARCHAR2(255)
					   );
			
			

CREATE SEQUENCE seqWilayas MINVALUE 1 MAXVALUE 100000 START WITH 1 INCREMENT BY 1;


--- création de la table nature économique------------


Create table DimensionNatureEconomic (Id_N_economic NUMBER PRIMARY KEY,
                       AXE_ECO  VARCHAR2(255),
					   LIBELLE VARCHAR2(255),
					   DISPOS VARCHAR2(255)
					   );
					  
CREATE SEQUENCE seqNatureEco MINVALUE 1 MAXVALUE 100000 START WITH 1 INCREMENT BY 1;


--- création de la table Dtemps------------

CREATE TABLE Dimensiontemps (
    Id_Temps NUMBER PRIMARY KEY,
    Jour DATE,
    LibJour VARCHAR2(20),
    Mois VARCHAR2(7),
    LibMois VARCHAR2(20),
    Annee NUMBER
);


--- Création de la séquence SeqTemps------------

CREATE SEQUENCE seqTemps MINVALUE 1 MAXVALUE 100000 START WITH 1 INCREMENT BY 1;

--- création de la table Activité------------


Create table DimensionActivite (ID_activite NUMBER PRIMARY KEY,
                       CODE_PORTEF VARCHAR2(255),
					   LIB_PORTEF VARCHAR2(255),
					   PROGRAMME VARCHAR2(255),
					   LIBELLE_PROG VARCHAR2(255),
					   SOUS_PROGRAMME VARCHAR2(255),
					   LIBELLE_sousProgramme VARCHAR2(255),
					   ACTION VARCHAR2(255),
                       LIBELLE_ACTION VARCHAR2(255),					   
					   SOUS_ACTION VARCHAR2(255)
					   );
					   
					  

					  
CREATE SEQUENCE seqActivite MINVALUE 1 MAXVALUE 100000 START WITH 1 INCREMENT BY 1;


--- création de la table de fait FaitCredit------------

Create table FaitCredit (
Id_Ordonnateur Number,
Id_Temps NUMBER,
Id_Wilayas NUMBER,
ID_activite NUMBER,
Id_N_economic NUMBER,
Credit_Total VARCHAR(255),
Credit_Consome VARCHAR(255),
Solde VARCHAR(255),
CONSTRAINT pk_FaitCredit PRIMARY KEY (Id_Ordonnateur,Id_Temps,Id_Wilayas,ID_activite,Id_N_economic,Credit_Total,Credit_Consome, Solde),
CONSTRAINT fk_FaitCredit_DimensionWilayas FOREIGN KEY (Id_Wilayas) REFERENCES DimensionWilayas (Id_Wilayas),
CONSTRAINT fk_FaitCredit_DimensionActivite FOREIGN KEY (ID_activite) REFERENCES DimensionActivite (ID_activite),
CONSTRAINT fk_FaitCredit_Dimensiontemps FOREIGN KEY (Id_Temps) REFERENCES Dimensiontemps (Id_Temps),
CONSTRAINT fk_FaitCredit_DimensionOrdonnateur FOREIGN KEY (Id_Ordonnateur) REFERENCES DimensionOrdonnateur (Id_Ordonnateur),
CONSTRAINT fk_FaitCredit_DimensionNatureEconomic FOREIGN KEY (Id_N_economic) REFERENCES DimensionNatureEconomic (Id_N_economic)
)PARTITION BY RANGE (ID_activite)(
  PARTITION A1 VALUES LESS THAN (1000),
  PARTITION A2 VALUES LESS THAN (5000),
  PARTITION A3 VALUES LESS THAN (100000),
  PARTITION A4 VALUES LESS THAN (MAXVALUE)
);


GRANT SELECT ON DBA_PART_TABLES TO Master2Il;
COMMIT;
-- Vérification des partitions
SELECT TABLE_NAME, PARTITION_NAME, HIGH_VALUE, PARTITION_POSITION
FROM USER_TAB_PARTITIONS U
WHERE U.TABLE_NAME = 'FAITCREDIT';








--- alimentation de la table de faitCredit + dimensionActivité + DimensionTemps + dimwilayas + dimNatureeconomique + dimOrdonnateur------------


---Pour exécuter automatiquement le code PL/SQL chaque fois qu'il y a des ajouts dans la table crédit, 
--on va pout utiliser des déclencheurs (triggers) dans Oracle

create or replace NONEDITIONABLE TRIGGER trg_insert_DimOrd_DimAct_Dtemps_DimWil_FaitCredit
AFTER INSERT ON projetMaster.Credit
FOR EACH ROW 
DECLARE
   V_ID_ACTIVITE NUMBER;
   v_Id_Temps NUMBER;
   v_CODE_PORTEF VARCHAR2(255);
   v_PROGRAMME VARCHAR2(255);
   v_SOUS_PROGRAMME VARCHAR2(255);
   v_ACTION VARCHAR2(255);
   v_SOUS_ACTION VARCHAR2(255);
   v_LIBELLE_Programme VARCHAR2(255);
   v_LIBELLE_sousProgramme VARCHAR2(255);
   v_LIB_PORTEF VARCHAR2(255);
   v_LIBELLE_ACTION VARCHAR2(255);
   v_jour VARCHAR2(255);
   v_libjour VARCHAR2(255); 
   v_mois  VARCHAR2(255);
   v_libmois VARCHAR2(255);
   v_annee VARCHAR2(255);
   GESTION VARCHAR(255);
   MOIS VARCHAR(255);
   v_jour_date DATE;
   v_countDT NUMBER;
   v_countDA NUMBER;
   v_countDO NUMBER;
   v_countDW NUMBER;
   V_COUNTDN NUMBER;
   v_Id_Ordonnateur NUMBER;
   v_Id_N_economic Number;
   v_Id_Wilayas NUMBER;
   v_TOT_CREDIT VARCHAR(255);
   v_TOT_DEB VARCHAR(255);
   v_SOLDE VARCHAR(255);
   v_Code_Ordonnateur VARCHAR2(255);
   v_Libelle_Ordonnateur VARCHAR2(255);
   v_CODE_WILAYA VARCHAR2(255);
   v_LIBELLE_WILAYA VARCHAR2(255);
   v_AXE_ECO VARCHAR2(255);
   v_LIBELLE VARCHAR2(255);
   v_Dispos VARCHAR2(255);
BEGIN


-- Logique de vérification et d'insertion dans DimensionActivite
   SELECT COUNT(*)
   INTO v_countDA
   FROM DimensionActivite DA
   WHERE :NEW.CODE_PORTEF = DA.CODE_PORTEF
      AND :NEW.PROGRAMME = DA.PROGRAMME
      AND :NEW.SOUS_PROGRAMME = DA.SOUS_PROGRAMME
      AND :NEW.ACTION = DA.ACTION
      AND :NEW.SOUS_ACTION = DA.SOUS_ACTION;


  -- Logique de déclencheur pour l'insertion dans DimensionActivite
  IF v_countDA = 0 THEN

   SELECT
      seqActivite.NEXTVAL,
      :NEW.CODE_PORTEF, 
      :NEW.PROGRAMME, 
      :NEW.SOUS_PROGRAMME, 
      :NEW.ACTION,
      :NEW.SOUS_ACTION,
      :NEW.MOIS,
      :NEW.GESTION
   INTO
      v_ID_Activite ,
      v_CODE_PORTEF,
      v_PROGRAMME,
      v_SOUS_PROGRAMME,
      v_ACTION,
      v_SOUS_ACTION,
      MOIS,
      GESTION
   FROM 
      dual;

   -- Logique de sélection des libellés à partir des jointures
   SELECT
      AP.LIBELLE 
   INTO
      v_LIBELLE_sousProgramme
   FROM 
      projetMaster.AxeProgramatique AP,projetMaster.Action A
   WHERE
      AP.CODE_PORTEF = :NEW.CODE_PORTEF
      AND AP.PROGRAMME = :NEW.PROGRAMME
      AND AP.SOUS_PROGRAMME = :NEW.SOUS_PROGRAMME
      AND A.ACTION = :NEW.ACTION
      AND A.SOUS_ACTION = :NEW.SOUS_ACTION
      AND ROWNUM = 1;

   SELECT
      AP.LIBELLE 
   INTO
      v_LIB_PORTEF
   FROM 
      projetMaster.AxeProgramatique AP,projetMaster.Action A
   WHERE
      AP.CODE_PORTEF = :NEW.CODE_PORTEF
      AND AP.PROGRAMME = :NEW.PROGRAMME
      AND AP.SOUS_PROGRAMME = :NEW.SOUS_PROGRAMME
      AND A.ACTION = :NEW.ACTION
      AND A.SOUS_ACTION = :NEW.SOUS_ACTION
      AND ROWNUM = 1;

   SELECT
      A.LIBELLE_ACTION 
   INTO
      v_LIBELLE_ACTION
   FROM 
      projetMaster.AxeProgramatique AP,projetMaster.Action A
   WHERE
      AP.CODE_PORTEF = :NEW.CODE_PORTEF
      AND AP.PROGRAMME = :NEW.PROGRAMME
      AND AP.SOUS_PROGRAMME = :NEW.SOUS_PROGRAMME
      AND A.ACTION = :NEW.ACTION
      AND A.SOUS_ACTION = :NEW.SOUS_ACTION
      AND ROWNUM = 1;

   SELECT
      AP.LIBELLE 
   INTO
      v_LIBELLE_Programme
   FROM 
      projetMaster.AxeProgramatique AP,projetMaster.Action A
   WHERE
      AP.SOUS_PROGRAMME = '00' 
      AND :NEW.CODE_PORTEF = AP.CODE_PORTEF 
      AND :NEW.PROGRAMME = AP.PROGRAMME
      AND ROWNUM = 1;

   INSERT INTO DimensionActivite (ID_activite,CODE_PORTEF,LIB_PORTEF, PROGRAMME, LIBELLE_PROG, SOUS_PROGRAMME,LIBELLE_sousProgramme, ACTION,LIBELLE_ACTION, SOUS_ACTION)
   VALUES (v_ID_Activite,v_CODE_PORTEF,v_LIB_PORTEF, v_PROGRAMME, v_LIBELLE_Programme, v_SOUS_PROGRAMME,v_LIBELLE_sousProgramme, v_ACTION,v_LIBELLE_ACTION, v_SOUS_ACTION);

END IF;

   -- Logique de vérification et d'insertion dans Dimensiontemps par les dates de crédit
  SELECT COUNT(*) INTO v_countDT
    FROM Dimensiontemps DT
    WHERE DT.Jour = TO_DATE('01/' || :NEW.MOIS || '/' || :NEW.GESTION, 'DD/MM/YYYY');

    IF v_countDT = 0 THEN
        v_jour := '01/' || :NEW.MOIS || '/' || :NEW.GESTION;
        v_jour_date := TO_DATE(v_jour, 'DD/MM/YYYY HH24:MI:SS'); -- Ajoutez le format de l'heure si nécessaire
        v_libjour := TO_CHAR(v_jour_date, 'DY');
        v_mois := TO_CHAR(v_jour_date, 'MM');
        v_libmois := TO_CHAR(v_jour_date, 'Month');
        v_annee := :NEW.GESTION; -- Utilisation directe de :NEW.GESTION si c'est l'année

        SELECT seqTemps.NEXTVAL INTO v_Id_Temps FROM dual;

        INSERT INTO Dimensiontemps (Id_Temps, Jour, LibJour, Mois, LibMois, Annee)
        VALUES (v_Id_Temps, v_jour_date, v_libjour, v_mois, v_libmois, v_annee);

    END IF;



	-- Logique de vérification et d'insertion dans DimensionOrdonnateur
   SELECT COUNT(*)
   INTO v_countDO
   FROM DimensionOrdonnateur DO
   WHERE :NEW.CODE_ORD = DO.Code_Ordonnateur;


  -- Logique de déclencheur pour l'insertion dans DimensionOrdonnateur
  IF v_countDO = 0 THEN

  SELECT
      seqOrdonnateur.NEXTVAL,
      :NEW.CODE_ORD
   INTO
      v_Id_Ordonnateur,
      v_Code_Ordonnateur
   FROM
      dual;


   -- Logique de sélection des libellés à partir des jointures
   SELECT
      O.LIBELLE_ORD 
   INTO
      v_Libelle_Ordonnateur
   FROM 
      projetMaster.Ordonnateur O
   WHERE
      O.CODE_ORD = :NEW.CODE_ORD
      AND ROWNUM = 1;



   INSERT INTO DimensionOrdonnateur (Id_Ordonnateur, Code_Ordonnateur, Libelle_Ordonnateur)
   VALUES (v_Id_Ordonnateur, v_Code_Ordonnateur, v_Libelle_Ordonnateur);

   END IF;



   -- Logique de vérification et d'insertion dans DimensionWilayas
   SELECT COUNT(*)
   INTO v_countDW
   FROM DimensionWilayas DW
   WHERE SUBSTR(:NEW.CODE_ORD, LENGTH(:NEW.CODE_ORD) - 1, 2) = DW.CODE_WILAYA;


  -- Logique de déclencheur pour l'insertion dans DimensionWilayas
  IF v_countDW = 0 THEN

  SELECT
      seqWilayas.NEXTVAL,
      SUBSTR(:NEW.CODE_ORD, LENGTH(:NEW.CODE_ORD) - 1, 2)
   INTO
      v_Id_Wilayas,
      v_CODE_WILAYA
   FROM
      dual;


   -- Logique de sélection des libellés à partir des jointures
   SELECT
      W.LIBELLE_WILAYA 
   INTO
      v_LIBELLE_WILAYA
   FROM 
      projetMaster.Wilayas W
   WHERE
      SUBSTR(:NEW.CODE_ORD, LENGTH(:NEW.CODE_ORD) - 1, 2) = W.CODE_WILAYA
      AND ROWNUM = 1;



   INSERT INTO DimensionWilayas (Id_Wilayas, CODE_WILAYA, LIBELLE_WILAYA)
   VALUES (v_Id_Wilayas, v_CODE_WILAYA, v_LIBELLE_WILAYA);

   END IF;
   
   
   
   
   -- Logique de vérification et d'insertion dans DimensionNatureEconomic
   SELECT COUNT(*)
   INTO v_countDN
   FROM DimensionNatureEconomic DN
   WHERE :NEW.AXE_ECO = DN.AXE_ECO
        AND :NEW.DISPOS = DN.DISPOS;


  -- Logique de déclencheur pour l'insertion dans DimensionNatureEconomic
  
  
  IF v_countDN = 0 THEN

  SELECT
      seqNatureEco.NEXTVAL,
      :NEW.AXE_ECO,
	  :NEW.DISPOS
   INTO
      v_Id_N_economic,
      v_AXE_ECO,
	  v_Dispos
   FROM
      dual;


   -- Logique de sélection des libellés à partir des jointures
   SELECT
      AE.LIBELLE
   INTO
      v_LIBELLE
   FROM 
      projetMaster.AxeEconomique AE
   WHERE
          :NEW.AXE_ECO = AE.AXE_ECO
      AND ROWNUM = 1;



   INSERT INTO DimensionNatureEconomic (Id_N_economic, AXE_ECO, LIBELLE,DISPOS)
   VALUES (v_Id_N_economic, v_AXE_ECO, v_LIBELLE,v_Dispos);

   END IF;

   -- Logique de sélection et d'insertion dans FaitCredit
   SELECT
      DT.Id_Temps,
      DO.Id_Ordonnateur,
      DW.Id_Wilayas,
      DA.ID_activite,
      DE.Id_N_economic,
      :NEW.TOT_CREDIT,
      :NEW.TOT_DEB,
      :NEW.SOLDE
   INTO 
      v_Id_Temps,
      v_Id_Ordonnateur,
      v_Id_Wilayas,
      v_ID_activite,
      v_Id_N_economic,
      v_TOT_CREDIT,
      v_TOT_DEB,
      v_SOLDE
   FROM  
      DimensionActivite DA,
      DimensionWilayas DW,
      DimensionOrdonnateur DO,
      DimensionNatureEconomic DE,
      Dimensiontemps DT
   WHERE
      :NEW.CODE_PORTEF = DA.CODE_PORTEF
      AND :NEW.PROGRAMME = DA.PROGRAMME
      AND :NEW.SOUS_PROGRAMME = DA.SOUS_PROGRAMME
      AND :NEW.ACTION = DA.ACTION
      AND :NEW.AXE_ECO = DE.AXE_ECO
	  AND :NEW.DISPOS = DE.DISPOS
      AND :NEW.SOUS_ACTION = DA.SOUS_ACTION
      AND :NEW.GESTION = DT.Annee
      AND SUBSTR(:NEW.CODE_ORD, LENGTH(:NEW.CODE_ORD) - 1, 2) = DW.CODE_WILAYA
      AND :NEW.CODE_ORD = DO.Code_Ordonnateur
      AND :NEW.MOIS = DT.Mois
      AND ROWNUM = 1
   GROUP BY
      DT.Id_Temps,
      DO.Id_Ordonnateur,
      DW.Id_Wilayas,
      DA.ID_activite,
      DE.Id_N_economic,
      :NEW.TOT_CREDIT,
      :NEW.TOT_DEB,
      :NEW.SOLDE;

   INSERT INTO FaitCredit (Id_Temps, Id_Ordonnateur, Id_Wilayas, ID_activite, Id_N_economic, Credit_Total, Credit_Consome, Solde)
   VALUES (v_Id_Temps, v_Id_Ordonnateur, v_Id_Wilayas, v_ID_activite,v_Id_N_economic, v_TOT_CREDIT, v_TOT_DEB, v_SOLDE);


END;
/

/****************************************************FAIT CREDIT************************************************/


/****************************************************FAIT DEPENSES************************************************/



--- création de la table DimMandat------------


Create table DimensionMandat (Id_Mandat NUMBER PRIMARY KEY,
                       Annee_gestion  VARCHAR2(255),
					   numero_mandat VARCHAR2(255), 
					   Status_Mandat VARCHAR2(255)
					   );
					   

CREATE SEQUENCE seqMandat MINVALUE 1 MAXVALUE 100000 START WITH 1 INCREMENT BY 1;

--- création de la table De fait FaitDepenes------------


Create table FaitDepenses (
Id_Temps NUMBER,
Id_Ordonnateur NUMBER,
Id_Wilayas NUMBER,
ID_activite NUMBER,
Id_N_economic NUMBER,
ID_Mandat Number,
MONTANT VARCHAR2(255),
CONSTRAINT pk_FaitDepenses PRIMARY KEY (Id_Temps,Id_Ordonnateur,Id_Wilayas,ID_activite,ID_Mandat,MONTANT),
CONSTRAINT fk_FaitDepenes_DimensionOrdonnateur FOREIGN KEY (Id_Ordonnateur) REFERENCES DimensionOrdonnateur (Id_Ordonnateur),
CONSTRAINT fk_FaitDepenses_DimensionWilayas FOREIGN KEY (Id_Wilayas) REFERENCES DimensionWilayas (Id_Wilayas),
CONSTRAINT fk_FaitDepenses_Dimensiontemps FOREIGN KEY (Id_Temps) REFERENCES Dimensiontemps (Id_Temps),
CONSTRAINT fk_FaitDepenses_DimensionActivite FOREIGN KEY (ID_activite) REFERENCES DimensionActivite (ID_activite),
CONSTRAINT fk_FaitDepenses_DimensionMandat FOREIGN KEY (ID_Mandat) REFERENCES DimensionMandat (ID_Mandat),
CONSTRAINT fk_FaitDepenses_DimensionNatureEconomic FOREIGN KEY (Id_N_economic) REFERENCES DimensionNatureEconomic (Id_N_economic)
)PARTITION BY RANGE (ID_Mandat)(
  PARTITION M1 VALUES LESS THAN (1000),
  PARTITION M2 VALUES LESS THAN (5000),
  PARTITION M3 VALUES LESS THAN (100000),
  PARTITION M4 VALUES LESS THAN (MAXVALUE)
);


SET SERVEROUTPUT ON;
GRANT SELECT ON DBA_PART_TABLES TO Master2Il;
COMMIT;


-- Vérification des partitions
SELECT TABLE_NAME, PARTITION_NAME, HIGH_VALUE, PARTITION_POSITION
FROM USER_TAB_PARTITIONS U
WHERE U.TABLE_NAME = 'FAITDEPENSES';


--- alimentation de la table de faitDépenses + dimensionActivité + DimensionTemps + dimwilayas + dimNatureeconomique + dimOrdonnateur + dimensionMandat------------
---Pour exécuter automatiquement le code PL/SQL chaque fois qu'il y a des ajouts dans la table Mandat, 
--on va pout utiliser des déclencheurs (triggers) dans Oracle

create or replace NONEDITIONABLE TRIGGER trg_insert_mandat_temps_dimensionActivite_FaitDepenses
AFTER INSERT ON projetMaster.Mandat
FOR EACH ROW
DECLARE
   v_Dispos VARCHAR2(255);
   v_Id_Mandat NUMBER;
   v_Annee_gestion VARCHAR2(4);
   v_numero_mandat VARCHAR2(20);
   v_Status_Mandat VARCHAR2(50);
   V_ID_ACTIVITE NUMBER;
   v_Id_Temps NUMBER;
   v_CODE_PORTEF VARCHAR2(255);
   v_PROGRAMME VARCHAR2(255);
   v_SOUS_PROGRAMME VARCHAR2(255);
   v_ACTION VARCHAR2(255);
   v_SOUS_ACTION VARCHAR2(255);
   v_LIBELLE_Programme VARCHAR2(255);
   v_LIBELLE_sousProgramme VARCHAR2(255);
   v_LIB_PORTEF VARCHAR2(255);
   v_LIBELLE_ACTION VARCHAR2(255);
   v_jour DATE;
   v_libjour VARCHAR2(255); 
   v_mois  VARCHAR2(255);
   v_libmois VARCHAR2(255);
   v_annee NUMBER;
   GESTION VARCHAR(255);
   v_jour_date DATE;
   v_countDT NUMBER;
   v_countDA NUMBER;
   v_countDO NUMBER;
   v_countDW NUMBER;
   V_COUNTDN NUMBER;
   v_countDM NUMBER;
   v_Id_Ordonnateur NUMBER;
   v_Id_N_economic Number;
   v_Id_Wilayas NUMBER;
   v_SOLDE VARCHAR(255);
   v_Code_Ordonnateur VARCHAR2(255);
   v_Libelle_Ordonnateur VARCHAR2(255);
   v_CODE_WILAYA VARCHAR2(255);
   v_LIBELLE_WILAYA VARCHAR2(255);
   v_AXE_ECO VARCHAR2(255);
   v_LIBELLE VARCHAR2(255);
   MONTANT VARCHAR2(255);
BEGIN

  -- Logique de vérification et d'insertion dans DimensionMandat
   SELECT COUNT(*)
   INTO v_countDM
   FROM DimensionMandat DM
   WHERE :NEW.GESTION = DM.Annee_gestion
        AND  :NEW.CODE_MANDAT =DM.numero_mandat
        AND  :NEW.STATUT = DM.Status_Mandat;


  -- Logique de déclencheur pour l'insertion dans DimensionMandat
  
  
  IF v_countDM = 0 THEN
   -- Insertion dans la table DimensionMandat
   SELECT
      seqMandat.NEXTVAL,
      :NEW.GESTION,
      :NEW.CODE_MANDAT,
      :NEW.STATUT
   INTO
      v_Id_Mandat,
      v_Annee_gestion,
      v_numero_mandat,
      v_Status_Mandat
   FROM
      dual;

   INSERT INTO DimensionMandat (Id_Mandat, Annee_gestion, numero_mandat, Status_Mandat)
   VALUES (v_Id_Mandat, v_Annee_gestion, v_numero_mandat, v_Status_Mandat);
   
 END IF;

   -- Logique de vérification et d'insertion dans DimensionActivite
   SELECT COUNT(*)
   INTO v_countDA
   FROM DimensionActivite DA
   WHERE :NEW.CODE_PORTEF = DA.CODE_PORTEF
      AND :NEW.PROGRAMME = DA.PROGRAMME
      AND :NEW.SOUS_PROGRAMME = DA.SOUS_PROGRAMME
      AND :NEW.ACTION = DA.ACTION
      AND :NEW.SOUS_ACTION = DA.SOUS_ACTION;


  -- Logique de déclencheur pour l'insertion dans DimensionActivite
  IF v_countDA = 0 THEN

   SELECT
      seqActivite.NEXTVAL,
      :NEW.CODE_PORTEF, 
      :NEW.PROGRAMME, 
      :NEW.SOUS_PROGRAMME, 
      :NEW.ACTION,
      :NEW.SOUS_ACTION,
      :NEW.GESTION
   INTO
      v_ID_Activite ,
      v_CODE_PORTEF,
      v_PROGRAMME,
      v_SOUS_PROGRAMME,
      v_ACTION,
      v_SOUS_ACTION,
      GESTION
   FROM 
      dual;

   -- Logique de sélection des libellés à partir des jointures
   SELECT
      AP.LIBELLE 
   INTO
      v_LIBELLE_sousProgramme
   FROM 
      projetMaster.AxeProgramatique AP,projetMaster.Action A
   WHERE
      AP.CODE_PORTEF = :NEW.CODE_PORTEF
      AND AP.PROGRAMME = :NEW.PROGRAMME
      AND AP.SOUS_PROGRAMME = :NEW.SOUS_PROGRAMME
      AND A.ACTION = :NEW.ACTION
      AND A.SOUS_ACTION = :NEW.SOUS_ACTION
      AND ROWNUM = 1;

   SELECT
      AP.LIBELLE 
   INTO
      v_LIB_PORTEF
   FROM 
      projetMaster.AxeProgramatique AP,projetMaster.Action A
   WHERE
      AP.CODE_PORTEF = :NEW.CODE_PORTEF
      AND AP.PROGRAMME = :NEW.PROGRAMME
      AND AP.SOUS_PROGRAMME = :NEW.SOUS_PROGRAMME
      AND A.ACTION = :NEW.ACTION
      AND A.SOUS_ACTION = :NEW.SOUS_ACTION
      AND ROWNUM = 1;

   SELECT
      A.LIBELLE_ACTION 
   INTO
      v_LIBELLE_ACTION
   FROM 
      projetMaster.AxeProgramatique AP,projetMaster.Action A
   WHERE
      AP.CODE_PORTEF = :NEW.CODE_PORTEF
      AND AP.PROGRAMME = :NEW.PROGRAMME
      AND AP.SOUS_PROGRAMME = :NEW.SOUS_PROGRAMME
      AND A.ACTION = :NEW.ACTION
      AND A.SOUS_ACTION = :NEW.SOUS_ACTION
      AND ROWNUM = 1;

   SELECT
      AP.LIBELLE 
   INTO
      v_LIBELLE_Programme
   FROM 
      projetMaster.AxeProgramatique AP,projetMaster.Action A
   WHERE
      AP.SOUS_PROGRAMME = '00' 
      AND :NEW.CODE_PORTEF = AP.CODE_PORTEF 
      AND :NEW.PROGRAMME = AP.PROGRAMME
      AND ROWNUM = 1;

   INSERT INTO DimensionActivite (ID_activite,CODE_PORTEF,LIB_PORTEF, PROGRAMME, LIBELLE_PROG, SOUS_PROGRAMME,LIBELLE_sousProgramme, ACTION,LIBELLE_ACTION, SOUS_ACTION)
   VALUES (v_ID_Activite,v_CODE_PORTEF,v_LIB_PORTEF, v_PROGRAMME, v_LIBELLE_Programme, v_SOUS_PROGRAMME,v_LIBELLE_sousProgramme, v_ACTION,v_LIBELLE_ACTION, v_SOUS_ACTION);

END IF;


   -- Logique de vérification et d'insertion dans DimensionOrdonnateur
   SELECT COUNT(*)
   INTO v_countDO
   FROM DimensionOrdonnateur DO
   WHERE :NEW.CODE_ORD = DO.Code_Ordonnateur;


  -- Logique de déclencheur pour l'insertion dans DimensionOrdonnateur
  IF v_countDO = 0 THEN

  SELECT
      seqOrdonnateur.NEXTVAL,
      :NEW.CODE_ORD
   INTO
      v_Id_Ordonnateur,
      v_Code_Ordonnateur
   FROM
      dual;


   -- Logique de sélection des libellés à partir des jointures
   SELECT
      O.LIBELLE_ORD 
   INTO
      v_Libelle_Ordonnateur
   FROM 
      projetMaster.Ordonnateur O
   WHERE
      O.CODE_ORD = :NEW.CODE_ORD
      AND ROWNUM = 1;



   INSERT INTO DimensionOrdonnateur (Id_Ordonnateur, Code_Ordonnateur, Libelle_Ordonnateur)
   VALUES (v_Id_Ordonnateur, v_Code_Ordonnateur, v_Libelle_Ordonnateur);

   END IF;



   -- Logique de vérification et d'insertion dans DimensionWilayas
   SELECT COUNT(*)
   INTO v_countDW
   FROM DimensionWilayas DW
   WHERE SUBSTR(:NEW.CODE_ORD, LENGTH(:NEW.CODE_ORD) - 1, 2) = DW.CODE_WILAYA;


  -- Logique de déclencheur pour l'insertion dans DimensionWilayas
  IF v_countDW = 0 THEN

  SELECT
      seqWilayas.NEXTVAL,
      SUBSTR(:NEW.CODE_ORD, LENGTH(:NEW.CODE_ORD) - 1, 2)
   INTO
      v_Id_Wilayas,
      v_CODE_WILAYA
   FROM
      dual;


   -- Logique de sélection des libellés à partir des jointures
   SELECT
      W.LIBELLE_WILAYA 
   INTO
      v_LIBELLE_WILAYA
   FROM 
      projetMaster.Wilayas W
   WHERE
      SUBSTR(:NEW.CODE_ORD, LENGTH(:NEW.CODE_ORD) - 1, 2) = W.CODE_WILAYA
      AND ROWNUM = 1;



   INSERT INTO DimensionWilayas (Id_Wilayas, CODE_WILAYA, LIBELLE_WILAYA)
   VALUES (v_Id_Wilayas, v_CODE_WILAYA, v_LIBELLE_WILAYA);

   END IF;




   -- Logique de vérification et d'insertion dans DimensionNatureEconomic
   SELECT COUNT(*)
   INTO v_countDN
   FROM DimensionNatureEconomic DN
   WHERE :NEW.AXE_ECO = DN.AXE_ECO
        AND :NEW.DISPOS = DN.DISPOS;


  -- Logique de déclencheur pour l'insertion dans DimensionNatureEconomic
  
  
  IF v_countDN = 0 THEN

  SELECT
      seqNatureEco.NEXTVAL,
      :NEW.AXE_ECO,
	  :NEW.DISPOS
   INTO
      v_Id_N_economic,
      v_AXE_ECO,
	  v_Dispos
   FROM
      dual;


   -- Logique de sélection des libellés à partir des jointures
   SELECT
      AE.LIBELLE
   INTO
      v_LIBELLE
   FROM 
      projetMaster.AxeEconomique AE
   WHERE
          :NEW.AXE_ECO = AE.AXE_ECO
      AND ROWNUM = 1;



   INSERT INTO DimensionNatureEconomic (Id_N_economic, AXE_ECO, LIBELLE,DISPOS)
   VALUES (v_Id_N_economic, v_AXE_ECO, v_LIBELLE,v_Dispos);

   END IF;


   -- Logique de vérification et d'insertion dans Dimensiontemps par les dates de Mandat
   SELECT COUNT(*)
   INTO v_countDT
   FROM Dimensiontemps
   WHERE Jour = TO_DATE(:NEW.DT_EMISSION,'DD/MM/YYYY');

   -- Insertion dans la table Dimensiontemps
  IF v_countDT = 0 THEN
   v_jour := TO_DATE(:NEW.DT_EMISSION, 'DD/MM/YYYY');
   v_libjour := TO_CHAR(v_jour, 'DY');
   v_mois := TO_CHAR(v_jour, 'MM');
   v_libmois := TO_CHAR(v_jour, 'Month');
   v_annee := EXTRACT(YEAR FROM v_jour);

   SELECT seqTemps.NEXTVAL INTO v_Id_Temps FROM dual;

   INSERT INTO Dimensiontemps (Id_Temps, Jour, LibJour, Mois, LibMois, Annee)
   VALUES (v_Id_Temps, v_jour, v_libjour, v_mois, v_libmois, v_annee);
  END IF;
  -- Logique de sélection et d'insertion dans FaitDepenses
   SELECT
      DT.Id_Temps,
      DO.Id_Ordonnateur,
      DW.Id_Wilayas,
      DA.ID_activite,
	  DE.Id_N_economic,
	  DM.ID_Mandat,
      :NEW.MONTANT
   INTO 
      v_Id_Temps,
      v_Id_Ordonnateur,
      v_Id_Wilayas,
      v_ID_activite,
	  v_Id_N_economic,
	  v_Id_Mandat,
      MONTANT
   FROM 
      DimensionActivite DA,
      DimensionWilayas DW,
      Dimensiontemps DT,
      DimensionOrdonnateur DO,
	  DimensionMandat DM,
	  DimensionNatureEconomic DE
   WHERE
      :NEW.CODE_PORTEF = DA.CODE_PORTEF
      AND :NEW.PROGRAMME = DA.PROGRAMME
      AND :NEW.SOUS_PROGRAMME = DA.SOUS_PROGRAMME
      AND :NEW.ACTION = DA.ACTION
      AND :NEW.SOUS_ACTION = DA.SOUS_ACTION
      AND :NEW.AXE_ECO = DE.AXE_ECO
      AND :NEW.DISPOS = DE.DISPOS
      AND SUBSTR(:NEW.CODE_ORD, LENGTH(:NEW.CODE_ORD) - 1, 2) = DW.CODE_WILAYA
      AND :NEW.CODE_ORD = DO.Code_Ordonnateur
      AND TO_DATE(:NEW.DT_EMISSION,'DD/MM/YYYY') = DT.Jour
	  AND :NEW.GESTION  = DM.Annee_gestion
	  AND :NEW.CODE_MANDAT = DM.numero_mandat
	  AND :NEW.STATUT = DM.Status_Mandat
      AND ROWNUM = 1
   GROUP BY
      DT.Id_Temps,
      DO.Id_Ordonnateur,
      DW.Id_Wilayas,
      DA.ID_activite,
	  DE.Id_N_economic,
	  DM.ID_Mandat,
      :NEW.MONTANT;

   INSERT INTO FaitDepenses (Id_Temps,Id_Ordonnateur,Id_Wilayas,ID_activite,Id_N_economic,ID_Mandat,MONTANT)
   VALUES (v_Id_Temps, v_Id_Ordonnateur, v_Id_Wilayas, v_ID_activite,v_Id_N_economic,v_Id_Mandat,MONTANT);

END;
/

/****************************************************FAIT DEPENSES************************************************/

/****************************************************FAIT RECETTES************************************************/



--- création de la table DimCompte------------

Create table DimensionCompte (Id_Compte NUMBER PRIMARY KEY,
                       CODE_CPT  VARCHAR2(255),
					   LIB_CPT_G VARCHAR2(255)
					   );
					   

CREATE SEQUENCE seqCompte MINVALUE 1 MAXVALUE 100000 START WITH 1 INCREMENT BY 1;

--- création de la table De fait FaitRecettes------------


Create table FaitRecettes(
Id_Temps NUMBER,
Id_Compte NUMBER,
Id_Wilayas NUMBER,
MONTANT VARCHAR2(255),
CONSTRAINT pk_FaitRecettes PRIMARY KEY (Id_Temps,Id_Compte,Id_Wilayas,MONTANT),
CONSTRAINT fk_FaitRecettes_DimensionCompte FOREIGN KEY (Id_Compte) REFERENCES DimensionCompte (Id_Compte),
CONSTRAINT fk_FaitRecettes_DimensionWilayas FOREIGN KEY (Id_Wilayas) REFERENCES DimensionWilayas (Id_Wilayas),
CONSTRAINT fk_FaitRecettes_Dimensiontemps FOREIGN KEY (Id_Temps) REFERENCES Dimensiontemps (Id_Temps)
)PARTITION BY RANGE (Id_Compte)(
PARTITION C1 VALUES LESS THAN (1000),
PARTITION C2 VALUES LESS THAN (5000),
PARTITION C3 VALUES LESS THAN (100000),
PARTITION C4 VALUES LESS THAN (MAXVALUE)
);



GRANT SELECT ON DBA_PART_TABLES TO Master2Il;
COMMIT;


-- Vérification des partitions
SELECT TABLE_NAME, PARTITION_NAME, HIGH_VALUE, PARTITION_POSITION
FROM USER_TAB_PARTITIONS U
WHERE U.TABLE_NAME = 'FAITRECETTES';
					   

--- alimentation de la table de faitRecette + dimensionCompte + DimensionTemps + dimwilayas------------
---Pour exécuter automatiquement le code PL/SQL chaque fois qu'il y a des ajouts dans la table Recette, 
--on va pout utiliser des déclencheurs (triggers) dans Oracle
CREATE OR REPLACE NONEDITIONABLE TRIGGER trg_insert_DimCpt_Dtemps_DimWil_FaitRecettes
AFTER INSERT ON projetMaster.Recette
FOR EACH ROW 
DECLARE
    v_Id_Temps NUMBER;
    v_jour VARCHAR2(255);
    v_libjour VARCHAR2(255); 
    v_mois VARCHAR2(255);
    v_libmois VARCHAR2(255);
    v_annee VARCHAR2(255);
    GESTION VARCHAR(255);
    MOIS VARCHAR(255);
    v_jour_date DATE;
    v_countDT NUMBER;
    v_countDW NUMBER;
    v_countDC NUMBER;
    v_Id_Compte NUMBER;
    v_Id_Wilayas NUMBER;
    v_Code_Compte VARCHAR2(255);
    v_Libelle_Compte VARCHAR2(255);
    v_CODE_WILAYA VARCHAR2(255);
    v_LIBELLE_WILAYA VARCHAR2(255);
    v_MT_MOIS VARCHAR2(255);
BEGIN
    -- Logique de vérification et d'insertion dans Dimensiontemps par les dates de Recette
    SELECT COUNT(*) INTO v_countDT
    FROM Dimensiontemps DT
    WHERE DT.Jour = TO_DATE('01/' || :NEW.MOIS || '/' || :NEW.GESTION, 'DD/MM/YYYY');

    IF v_countDT = 0 THEN
        v_jour := '01/' || :NEW.MOIS || '/' || :NEW.GESTION;
        v_jour_date := TO_DATE(v_jour, 'DD/MM/YYYY HH24:MI:SS'); -- Ajoutez le format de l'heure si nécessaire
        v_libjour := TO_CHAR(v_jour_date, 'DY');
        v_mois := TO_CHAR(v_jour_date, 'MM');
        v_libmois := TO_CHAR(v_jour_date, 'Month');
        v_annee := :NEW.GESTION; -- Utilisation directe de :NEW.GESTION si c'est l'année

        SELECT seqTemps.NEXTVAL INTO v_Id_Temps FROM dual;

        INSERT INTO Dimensiontemps (Id_Temps, Jour, LibJour, Mois, LibMois, Annee)
        VALUES (v_Id_Temps, v_jour_date, v_libjour, v_mois, v_libmois, v_annee);
    END IF;

    -- Logique de vérification et d'insertion dans DimensionCompte
    SELECT COUNT(*)
    INTO v_countDC
    FROM DimensionCompte DC
    WHERE :NEW.CODE_CPT = DC.CODE_CPT;

    IF v_countDC = 0 THEN
        SELECT seqCompte.NEXTVAL INTO v_Id_Compte FROM dual;

        INSERT INTO DimensionCompte (Id_Compte, CODE_CPT, LIB_CPT_G)
        VALUES (v_Id_Compte, :NEW.CODE_CPT, :NEW.LIB_CPT_G);
    ELSE
        SELECT Id_Compte INTO v_Id_Compte
        FROM DimensionCompte
        WHERE CODE_CPT = :NEW.CODE_CPT
        AND ROWNUM = 1; -- Assurez-vous qu'une seule ligne est retournée
    END IF;

    -- Logique de vérification et d'insertion dans DimensionWilayas
    SELECT COUNT(*)
    INTO v_countDW
    FROM DimensionWilayas DW
    WHERE :NEW.POSTE_C = DW.CODE_WILAYA;

    IF v_countDW = 0 THEN
        SELECT seqWilayas.NEXTVAL INTO v_Id_Wilayas FROM dual;

        -- Logique de sélection des libellés à partir des jointures
        SELECT W.LIBELLE_WILAYA
        INTO v_LIBELLE_WILAYA
        FROM projetMaster.Wilayas W
        WHERE :NEW.POSTE_C = W.CODE_WILAYA
        AND ROWNUM = 1; -- Assurez-vous qu'une seule ligne est retournée

        INSERT INTO DimensionWilayas (Id_Wilayas, CODE_WILAYA, LIBELLE_WILAYA)
        VALUES (v_Id_Wilayas, :NEW.POSTE_C, v_LIBELLE_WILAYA);
    ELSE
        SELECT Id_Wilayas INTO v_Id_Wilayas
        FROM DimensionWilayas
        WHERE CODE_WILAYA = :NEW.POSTE_C
        AND ROWNUM = 1; -- Assurez-vous qu'une seule ligne est retournée
    END IF;

    -- Logique de sélection et d'insertion dans FaitRecettes
    SELECT DT.Id_Temps, DC.Id_Compte, DW.Id_Wilayas, :NEW.MT_MOIS
    INTO v_Id_Temps, v_Id_Compte, v_Id_Wilayas, v_MT_MOIS
    FROM Dimensiontemps DT, DimensionCompte DC, DimensionWilayas DW
    WHERE DT.Annee = :NEW.GESTION
    AND DT.Mois = :NEW.MOIS
    AND DW.CODE_WILAYA = :NEW.POSTE_C
    AND DC.CODE_CPT = :NEW.CODE_CPT
    AND ROWNUM = 1; -- Assurez-vous qu'une seule ligne est retournée

    INSERT INTO FaitRecettes (Id_Temps, Id_Compte, Id_Wilayas, MONTANT)
    VALUES (v_Id_Temps, v_Id_Compte, v_Id_Wilayas, :NEW.MT_MOIS);
END;

/

/****************************************************FAIT RECETTE************************************************/
					   
					   
/****************************************************FAIT Dette************************************************/
--- création de la table DimSoumissionaire------------

Create table DimensionSoumissionaire (Id_Soumissionaire NUMBER PRIMARY KEY,
                       CODE_Soumissionaire  VARCHAR2(255),
					   LIBELLE_Soumissionaire VARCHAR2(255)
					   );
					   
CREATE SEQUENCE seqSoumissionaire MINVALUE 1 MAXVALUE 100000 START WITH 1 INCREMENT BY 1;

--- création de la table DimTitre------------



Create table DimensionTitre (Id_Titre NUMBER PRIMARY KEY,
                       code_ISIN  VARCHAR2(255),
					   DUREE_bon VARCHAR2(255)
					   );
					   

CREATE SEQUENCE seqTitre MINVALUE 1 MAXVALUE 100000 START WITH 1 INCREMENT BY 1;



--- création de la table De fait FaitDette ------------


Create table FaitDette(
Id_Temps NUMBER,
Id_Titre NUMBER,
Id_Soumissionaire NUMBER,
MONTANT_Propose_Par_etat VARCHAR2(255),
Montant_Propose_Par_Soumissionaire VARCHAR2(255),
Montant_Adjuge VARCHAR2(255),
Montant_Coupoun VARCHAR2(255),
CONSTRAINT pk_FaitDette PRIMARY KEY (Id_Temps,Id_Titre,Id_Soumissionaire,MONTANT_Propose_Par_etat,Montant_Propose_Par_Soumissionaire,Montant_Adjuge,Montant_Coupoun),
CONSTRAINT fk_FaitDette_DimensionTitre FOREIGN KEY (Id_Titre) REFERENCES DimensionTitre (Id_Titre),
CONSTRAINT fk_FaitDette_DimensionSoumissionaire FOREIGN KEY (Id_Soumissionaire) REFERENCES DimensionSoumissionaire (Id_Soumissionaire),
CONSTRAINT fk_FaitDette_Dimensiontemps FOREIGN KEY (Id_Temps) REFERENCES Dimensiontemps (Id_Temps)				   
)PARTITION BY RANGE (Id_Titre)(
PARTITION T1 VALUES LESS THAN (1000),
PARTITION T2 VALUES LESS THAN (5000),
PARTITION T3 VALUES LESS THAN (100000),
PARTITION T4 VALUES LESS THAN (MAXVALUE)
);


GRANT SELECT ON DBA_PART_TABLES TO Master2Il;
COMMIT;


-- Vérification des partitions
SELECT TABLE_NAME, PARTITION_NAME, HIGH_VALUE, PARTITION_POSITION
FROM USER_TAB_PARTITIONS U
WHERE U.TABLE_NAME = 'FAITDETTE';


--- alimentation de la table de faitDette + dimensionTitre + DimensionTemps + DimensionSoumissionaire------------
---Pour exécuter automatiquement le code PL/SQL chaque fois qu'il y a des ajouts dans la table Recette, 
--on va pout utiliser des déclencheurs (triggers) dans Oracle
CREATE OR REPLACE NONEDITIONABLE TRIGGER trg_insert_DimSom_Dtemps_DimTitre_FaitDettes
AFTER INSERT ON projetMaster.Dette
FOR EACH ROW
DECLARE
    v_Id_Temps NUMBER;
    v_jour DATE;
    v_libjour VARCHAR2(10); 
    v_mois VARCHAR2(2);
    v_libmois VARCHAR2(15);
    v_annee NUMBER;
    v_countDT NUMBER;
    v_countDS NUMBER;
    v_countDC NUMBER;
    v_Id_Titre NUMBER;
    v_Id_Soumissionaire NUMBER;
    v_LIBELLE_Soumissionaire VARCHAR2(255);
BEGIN
    -- Logique de vérification et d'insertion dans Dimensiontemps par les dates de Dette
    SELECT COUNT(*)
    INTO v_countDT
    FROM Dimensiontemps
    WHERE Jour = TO_DATE(:NEW.DATE_DEB, 'DD/MM/YYYY');

    IF v_countDT = 0 THEN
        -- Date de début
        v_jour := TO_DATE(:NEW.DATE_DEB, 'DD/MM/YYYY');
        v_libjour := TO_CHAR(v_jour, 'DY', 'NLS_DATE_LANGUAGE=AMERICAN');
        v_mois := TO_CHAR(v_jour, 'MM');
        v_libmois := TO_CHAR(v_jour, 'Month', 'NLS_DATE_LANGUAGE=AMERICAN');
        v_annee := EXTRACT(YEAR FROM v_jour);

        SELECT seqTemps.NEXTVAL INTO v_Id_Temps FROM dual;

        INSERT INTO Dimensiontemps (Id_Temps, Jour, LibJour, Mois, LibMois, Annee)
        VALUES (v_Id_Temps, v_jour, v_libjour, v_mois, v_libmois, v_annee);

    END IF;
	
	
	-- Logique de vérification et d'insertion dans Dimensiontemps par les dates de Dette
	SELECT COUNT(*)
    INTO v_countDT
    FROM Dimensiontemps
    WHERE Jour = TO_DATE(:NEW.DATE_ECHEANCE, 'DD/MM/YYYY');

    IF v_countDT = 0 THEN
        -- Date d'échéance
        v_jour := TO_DATE(:NEW.DATE_ECHEANCE, 'DD/MM/YYYY');
        v_libjour := TO_CHAR(v_jour, 'DY', 'NLS_DATE_LANGUAGE=AMERICAN');
        v_mois := TO_CHAR(v_jour, 'MM');
        v_libmois := TO_CHAR(v_jour, 'Month', 'NLS_DATE_LANGUAGE=AMERICAN');
        v_annee := EXTRACT(YEAR FROM v_jour);

        SELECT seqTemps.NEXTVAL INTO v_Id_Temps FROM dual;

        INSERT INTO Dimensiontemps (Id_Temps, Jour, LibJour, Mois, LibMois, Annee)
        VALUES (v_Id_Temps, v_jour, v_libjour, v_mois, v_libmois, v_annee);

    END IF;
	
	

    -- Logique de vérification et d'insertion dans DimensionTitre
    SELECT COUNT(*)
    INTO v_countDT
    FROM DimensionTitre DT
    WHERE :NEW.code_ISIN = DT.code_ISIN;

    IF v_countDT = 0 THEN
        SELECT seqTitre.NEXTVAL INTO v_Id_Titre FROM dual;

        INSERT INTO DimensionTitre (Id_Titre, code_ISIN, DUREE_bon)
        VALUES (v_Id_Titre, :NEW.code_ISIN, :NEW.DUREE_bon);
    ELSE
        SELECT Id_Titre INTO v_Id_Titre
        FROM DimensionTitre
        WHERE code_ISIN = :NEW.code_ISIN
        AND ROWNUM = 1; -- Assurez-vous qu'une seule ligne est retournée
    END IF;

    -- Logique de vérification et d'insertion dans DimensionSoumissionaire
    SELECT COUNT(*)
    INTO v_countDS
    FROM DimensionSoumissionaire DS
    WHERE :NEW.CODE_Soumissionaire = DS.CODE_Soumissionaire;

    IF v_countDS = 0 THEN
        SELECT seqSoumissionaire.NEXTVAL INTO v_Id_Soumissionaire FROM dual;

        -- Logique de sélection des libellés à partir des jointures
        SELECT S.LIBELLE_Soumissionaire
        INTO v_LIBELLE_Soumissionaire
        FROM projetMaster.Soumissionaire S
        WHERE :NEW.CODE_Soumissionaire = S.CODE_Soumissionaire
        AND ROWNUM = 1; -- Assurez-vous qu'une seule ligne est retournée

        INSERT INTO DimensionSoumissionaire (Id_Soumissionaire, Code_Soumissionaire, LIBELLE_Soumissionaire)
        VALUES (v_Id_Soumissionaire, :NEW.CODE_Soumissionaire, v_LIBELLE_Soumissionaire);
    ELSE
        SELECT Id_Soumissionaire INTO v_Id_Soumissionaire
        FROM DimensionSoumissionaire
        WHERE CODE_Soumissionaire = :NEW.CODE_Soumissionaire
        AND ROWNUM = 1; -- Assurez-vous qu'une seule ligne est retournée
    END IF;

    -- Logique de sélection et d'insertion dans FaitDette
    SELECT DD.Id_Temps, DS.Id_Soumissionaire, DT.Id_Titre
    INTO v_Id_Temps, v_Id_Soumissionaire, v_Id_Titre
    FROM Dimensiontemps DD, DimensionSoumissionaire DS, DimensionTitre DT
    WHERE DT.code_ISIN = :NEW.code_ISIN
    AND DS.Code_Soumissionaire = :NEW.Code_Soumissionaire
    AND DD.Jour = TO_DATE(:NEW.DATE_DEB, 'DD/MM/YYYY')
    AND ROWNUM = 1; -- Assurez-vous qu'une seule ligne est retournée

    INSERT INTO FaitDette (Id_Temps, Id_Soumissionaire, Id_Titre, MONTANT_Propose_Par_etat, Montant_Propose_Par_Soumissionaire, Montant_Adjuge, Montant_Coupoun)
    VALUES (v_Id_Temps, v_Id_Soumissionaire, v_Id_Titre, :NEW.MONTANT_Propose_Par_etat, :NEW.Montant_Propose_Par_Soumissionaire, :NEW.Montant_Adjuge, :NEW.Montant_Coupoun);
	
	
	-- Logique de sélection et d'insertion dans FaitDette
    SELECT DD.Id_Temps, DS.Id_Soumissionaire, DT.Id_Titre
    INTO v_Id_Temps, v_Id_Soumissionaire, v_Id_Titre
    FROM Dimensiontemps DD, DimensionSoumissionaire DS, DimensionTitre DT
    WHERE DT.code_ISIN = :NEW.code_ISIN
    AND DS.Code_Soumissionaire = :NEW.Code_Soumissionaire
    AND DD.Jour = TO_DATE(:NEW.DATE_ECHEANCE, 'DD/MM/YYYY')
    AND ROWNUM = 1; -- Assurez-vous qu'une seule ligne est retournée

    INSERT INTO FaitDette (Id_Temps, Id_Soumissionaire, Id_Titre, MONTANT_Propose_Par_etat, Montant_Propose_Par_Soumissionaire, Montant_Adjuge, Montant_Coupoun)
    VALUES (v_Id_Temps, v_Id_Soumissionaire, v_Id_Titre, :NEW.MONTANT_Propose_Par_etat, :NEW.Montant_Propose_Par_Soumissionaire, :NEW.Montant_Adjuge, :NEW.Montant_Coupoun);
END;
/		

	   
					   
					   
/****************************************************FAIT Dette************************************************/
